\documentclass[a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage{enumitem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{ifsym}



\author{Gruppe 6}

\title{\textbf{VerteilteWebInf Hausaufgabe 3}}
\date{\today}



\newcommand{\LeftSemiJoin}{\textbf{\tiny \textifsym{|><}}}
\newcommand{\RightSemiJoin}{\textbf{\tiny	 \textifsym{><|}}}

\begin{document}
\maketitle


\section*{Aufgabe 1}
\begin{itemize}
\item $R \Join S = R \Join  (\Pi_C(R) \RightSemiJoin S)$\\

$"\Rightarrow"$ \\
$\forall t \in R \Join S: \exists t_1 \in R \land \exists t_2 \in S (t_1.C = t_2.C)$\\
$\Rightarrow t_2 \in (\Pi_C(R) \RightSemiJoin S) \Rightarrow t_1 \Join t_2 \Rightarrow t \in (R \Join (\Pi_C(R) \RightSemiJoin S))$, da  die Joinbedingung nur das Attribut C enthält.\\
Man erhält damit alle möglichen Joinpartner der Relation S zur Relation R. \\
$"\Leftarrow"$\\
$\forall t \in R \Join (\Pi_C(R) \RightSemiJoin S): \exists t_1 \in R \land \exists t_2 \in \Pi_C(R) \RightSemiJoin S (t_1.C = t_2.C)$\\
$\Rightarrow t_2 \in S \Rightarrow t_1 \Join t_2 \Rightarrow t \in R \Join S $\\

\item $R \Join S =  (\Pi_C(S) \RightSemiJoin R) \Join  (\Pi_C(R) \RightSemiJoin S)$\\

$"\Rightarrow"$ \\
$\forall t \in R \Join S: \exists t_1 \in R \land \exists t_2 \in S (t_1.C = t_2.C)$\\
$\Rightarrow t_1 \in (\Pi_C(S) \RightSemiJoin R) \land t_2 \in (\Pi_C(R) \RightSemiJoin S)$ \\
$\Rightarrow t_1 \Join t_2 \Rightarrow t \in ((\Pi_C(S) \RightSemiJoin R) \Join (\Pi_C(R) \RightSemiJoin S))$, da  die Joinbedingung nur das Attribut C enthält.\\
Auf der linken Seite des Joins erhält man somit alle Joinpartner von R  für S, auf der rechten Seite alle Joinpartner von S für R.\\
$"\Leftarrow"$\\
$\forall t \in (\Pi_C(S) \RightSemiJoin R) \Join (\Pi_C(R) \RightSemiJoin S): \exists t_1 \in (\Pi_C(S) \RightSemiJoin R) \land \exists t_2 \in \Pi_C(R) \RightSemiJoin S (t_1.C = t_2.C)$\\
$\Rightarrow t_1\in R \land t_2 \in S \Rightarrow t_1 \Join t_2 \Rightarrow t \in R \Join S $\\

%\item 
%
%Anderer Ansatz für a)
%\\
%Es gilt: \\
%$S \RightSemiJoin R = \Pi_{s_1 \ldots s_n}(R \Join S)$ mit $s_1 \ldots s_n$ sind %alle Attribute von S.
%\\
%Damit gilt:
%\\
%$R \Join S = R \Join  (\Pi_C(R) \RightSemiJoin S) = R \Join \Pi_{s_1 \ldots s_n}(S %\Join \Pi_{C}(R)) $





\end{itemize}


\section*{Aufgabe 2}
\begin{enumerate}[label=\alph*)]

\item $R_1=\{[\underline{id:integer}, TokenID:bigint]\}$\\
			$R_2=\{[\underline{id:integer}, CustomerID:integer]\}$\\
			$R_3=\{[\underline{id:integer}, StoreID:integer]\}$\\
			$R_4=\{[\underline{id:integer}, amount:numeric(7,2)]\}$\\
			$R_5=\{[\underline{id:integer}, time:timestamp]\}$
%set to f)
\setcounter{enumi}{5}
\item 3 Mio Datensätze: \\
\textbf{Query1:} \\
Column Store: 13 Millisekunden \\
Row Store: 35 Millisekunden \\
\textbf{Query2:} \\
Column Store: 412 Millisekunden \\
Row Store: 579 Millisekunden \\

Sowohl für Query1 als auch für Query2 ist die Column Store Implementierung schneller. Dies könnte vor allem daran liegen, dass Aggregationsfunktionen (OLAP) effizienter auf Spalten-basierten Systemen arbeiten können. Da nur die entsprechenden Spalten und nicht die gesamte Zeile einer Tabelle in den Speicher geladen werden muss.  



\end{enumerate}



\end{document}


